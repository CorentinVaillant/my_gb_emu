use std::{
    collections::{HashMap, HashSet},
    fs::{self, File},
    io::{Result, Write},
    path::{Path, PathBuf},
};
use serde::Deserialize;


// Output paths
const OPCODE_RS_ENUM_PATH: &str = "opcode_rs/enum.rs";
const OPCODE_RS_BYTE_TO_OPCODE_PATH: &str = "opcode_rs/byte_to_opcode.rs";
const OPCODE_RS_MNEMONICS_PATH: &str = "opcode_rs/mnemonic_enum.rs";
const OPCODE_RS_OPCODE_TO_MNEMONICS_PATH: &str = "opcode_rs/opcode_to_mnemonics.rs";

pub fn main() {
    println!("cargo::rerun-if-changed=build_resources/opcodes.json");
    println!("cargo::rustc-check-cfg=cfg(prefixed_opcode)");

    let json_str = include_str!("build_resources/opcodes.json");
    let data: JsonData = serde_json::from_str(json_str).expect("Could not read data");

    let out_dir = PathBuf::from(std::env::var("OUT_DIR").unwrap());

    write_enum_file(&data, &out_dir.join(OPCODE_RS_ENUM_PATH)).unwrap();
    write_byte_to_opcode_file(&data, &out_dir.join(OPCODE_RS_BYTE_TO_OPCODE_PATH)).unwrap();
    write_mnemonic_file(&data, &out_dir.join(OPCODE_RS_MNEMONICS_PATH)).unwrap();
    write_opcode_to_mnemonic_file(&data, &out_dir.join(OPCODE_RS_OPCODE_TO_MNEMONICS_PATH)).unwrap()
}

// === Data model ===
type JsonData = HashMap<String, HashMap<String, Instruction>>;

#[derive(Debug, Clone, Deserialize)]
struct Operand {
    name: String,
    decrement: Option<bool>,
    increment: Option<bool>,
    immediate: bool,
}

#[derive(Debug, Clone, Deserialize)]
struct Instruction {
    mnemonic: String,
    operands: Vec<Operand>,
}

// === File writers ===

fn write_enum_file(data: &JsonData, dest: &Path) -> Result<()> {
    let mut f = create_output_file(dest)?;

    writeln!(f, "// Generated by build.rs")?;
    // Unprefixed
    writeln!(f, "#[derive(Debug, Clone, Copy, PartialEq)]\npub enum Opcode {{")?;
    for (opcode, inst) in get_opcode_data_sorted(&data["unprefixed"]) {
        writeln!(f, "\t/*{opcode:02X}*/ {}, // {}", inst.to_string(""), inst.description())?;
    }
    writeln!(f, "}}\n")?;

    // Prefixed
    #[cfg(prefixed_opcode)]
    {
        writeln!(f, "#[derive(Debug, Clone, Copy, PartialEq)]\npub enum PrefixedOpcode {{")?;
        for (opcode, inst) in get_opcode_data_sorted(&data["cbprefixed"]) {
            writeln!(f, "\t/*{opcode:02X}*/ {},", inst.to_string(""))?;
        }
        writeln!(f, "}}")?;
    }

    Ok(())
}

fn write_byte_to_opcode_file(data: &JsonData, dest: &Path) -> Result<()> {
    let mut f = create_output_file(dest)?;

    writeln!(f, "// Generated by build.rs")?;

    // Unprefixed
    writeln!(f, "const fn byte_to_opcode(byte: u8) -> Opcode {{")?;
    writeln!(f, "\tmatch byte {{")?;
    for (opcode, inst) in get_opcode_data_sorted(&data["unprefixed"]) {
        writeln!(f, "\t\t0x{opcode:02X} => Opcode::{},", inst.to_string(""))?;
    }
    writeln!(f, "\t}}")?;
    writeln!(f, "}}")?;

    // Prefixed
    #[cfg(prefixed_opcode)]
    {
        writeln!(f, "\nconst fn byte_to_prefixed_opcode(byte: u8) -> PrefixedOpcode {{")?;
        writeln!(f, "\tmatch byte {{")?;
        for (opcode, inst) in get_opcode_data_sorted(&data["cbprefixed"]) {
            writeln!(f, "\t\t0x{opcode:02X} => PrefixedOpcode::{},", inst.to_string(""))?;
        }
        writeln!(f, "\t}}")?;
        writeln!(f, "}}")?;
    }

    Ok(())
}

fn write_mnemonic_file(data: &JsonData, dest: &Path) -> Result<()> {
    let mut f = create_output_file(dest)?;

    let mut mnemonics = HashSet::new();
    for inst in data["unprefixed"].values().chain(data["cbprefixed"].values()) {
        mnemonics.insert(to_camelcase(&inst.mnemonic.to_ascii_lowercase()));
    }

    writeln!(f, "// Generated by build.rs")?;
    writeln!(f, "#[derive(Debug, Clone, Copy, PartialEq)]")?;
    writeln!(f, "#[allow(dead_code)]")?;
    writeln!(f, "pub enum Mnemonic {{")?;
    for mnemonic in mnemonics {
        writeln!(f, "\t{},", mnemonic)?;
    }
    writeln!(f, "}}")?;

    Ok(())
}

fn write_opcode_to_mnemonic_file(data: &JsonData, dest: &Path) -> Result<()>{
    let mut f = create_output_file(dest)?;
    
    writeln!(f, "// Generated by build.rs")?;
    // Unprefixed
    writeln!(f, "impl Opcode {{")?;
    writeln!(f, "\tpub const fn get_mnemonic(&self)->Mnemonic{{")?;
    writeln!(f, "\t\tmatch self{{")?;
    
    for inst in data["unprefixed"].values(){
        writeln!(f, "\t\t\tOpcode::{} => Mnemonic::{},", inst.to_string(""), to_camelcase(&inst.mnemonic.to_ascii_lowercase()))?;
    }
    writeln!(f, "\t\t}}")?;
    writeln!(f, "\t}}")?;
    writeln!(f, "}}")?;

    // Prefixed
    #[cfg(prefixed_opcode)]
    {
        writeln!(f, "impl PrefixedOpcode {{")?;
        writeln!(f, "\tpub const fn get_mnemonic(&self)->Mnemonic{{")?;
        writeln!(f, "\t\tmatch self{{")?;
        
        for inst in data["cbprefixed"].values(){
            writeln!(f, "\t\t\tPrefixedOpcode::{} => Mnemonic::{},", inst.to_string(""), to_camelcase(&inst.mnemonic.to_ascii_lowercase()))?;
        }
        writeln!(f, "\t\t}}")?;
        writeln!(f, "\t}}")?;
        writeln!(f, "}}")?;
    }


    
    Ok(())
}

// === Helpers ===

fn create_output_file(path: &Path) -> Result<File> {
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent)?;
    }
    println!("Generating {:?}", path);
    File::create(path)
}

fn get_opcode_data_sorted(
    data: &HashMap<String, Instruction>,
) -> Vec<(u8, &Instruction)> {
    let mut v: Vec<_> = data.iter().map(|(hex, inst)| {
        let n = u8::from_str_radix(hex.trim_start_matches("0x"), 16).unwrap();
        (n, inst)
    }).collect();
    v.sort_by_key(|(n, _)| *n);
    v
}

fn to_camelcase(s: &str) -> String {
    s.split(|c: char| c == '_' || c.is_whitespace())
        .filter(|w| !w.is_empty())
        .map(|w| {
            let mut c = w.chars();
            match c.next() {
                None => String::new(),
                Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
            }
        })
        .collect()
}

// === Display helpers ===

impl Instruction {
    fn to_string(&self, sep: &str) -> String {
        let mut buff = to_camelcase(&self.mnemonic.to_ascii_lowercase());
        for op in &self.operands {
            let mut name = op.name.clone();
            if op.name.starts_with('$') {
                name = op.name[1..].to_string();
            } else if op.name.starts_with('a') {
                name = format!("AddrN{}", &op.name[1..]);
            } else if !op.immediate && op.name == "HL" {
                name = format!("Addr{}", op.name);
            }
            if op.decrement.unwrap_or(false) {
                name.push('d');
            } else if op.increment.unwrap_or(false) {
                name.push('i');
            }
            buff = format!("{buff}{sep}{}", to_camelcase(&name));
        }
        buff
    }

    fn description(&self) -> String {
        let mut buff = self.mnemonic.clone();
        for op in &self.operands {
            let mut name = op.name.clone();
            if !op.immediate && op.name == "HL" {
                name = format!("[{}]", name);
            } else if op.name.starts_with('a') {
                name = format!("[n{}]", &op.name[1..]);
            } else if op.name.starts_with('$') {
                name = op.name[1..].to_string();
            }
            if op.decrement.unwrap_or(false) {
                name.push('-');
            } else if op.increment.unwrap_or(false) {
                name.push('+');
            }
            buff.push(' ');
            buff.push_str(&name);
        }
        buff
    }
}
